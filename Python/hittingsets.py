
def run_hitting_set_algorithm(conflict_sets):
    """
    Algorithm that handles the entire process from conflict sets to hitting sets

    :param conflict_sets: list of conflict sets as list
    :return: hit_sets_list: list of hitting sets as a list
             min_hitting_sets_list: list of minimal hitting sets as a list
    """
    Conflict_sets_sorted = []
    conflict_sets_list = list(conflict_sets)

    """
    check Heuristic , the user inter the Heuristic number from 0 to 3 where 
    0= no Heuristic , 
    1= sort the conflict sets with the smallest set first
    2= sort the conflict sets with the Largest set first
    3= containing the most common elements
    """
    print('Enter Heuristic from 0 to 3:')
    heuristic = int(input())

    if heuristic == 0:
        Conflict_sets_sorted = conflict_sets_list
        print("Heuristic = 0", conflict_sets_list)
    elif heuristic == 1:      # sort the conflict sets with the smallest set first
        Conflict_sets_sorted = list(sorted(conflict_sets_list, key=len))
        print("Heuristic = 1", Conflict_sets_sorted)
    elif heuristic == 2:     # sort the conflict sets with the Largest set first
        Conflict_sets_sorted = list(sorted(conflict_sets_list, key=len, reverse=True))
        print("Heuristic = 2", Conflict_sets_sorted)
    elif heuristic == 3:     # containing the most common elements
        element_dic = {}
        for subset in conflict_sets_list:   # create dictionary with element counts
            for e in subset:
                if e in element_dic:
                    element_dic[e] += 1
                else:
                    element_dic[e] = 1
        weights = []    # get the element Weight for the supset
        for s in conflict_sets_list:
            weight = 0
            for e in s:
                weight += element_dic[e]
            weights.append((s, weight))

        Sorted_List = sorted(weights, key=lambda x: x[1], reverse=True) # sort the list the largest weight first
        print("Sorted_List = ", Sorted_List)
        for s,w in Sorted_List:
           Conflict_sets_sorted.append(s)
        print("Heuristic = 3", Conflict_sets_sorted)

    """
    find the unhit set in the sorted Conflict_sets_sorted generated by the Heuristic
    """
    def first_unhit_set(selection):
        # return the first conflict set not yet hit by 'selection', if all sets are hit return none
        for subset in Conflict_sets_sorted:
            hit = False
            for element in subset:
                if element in selection:
                    hit = True
                    break   # only stop checking this set
            if not hit:
                return subset   # return first unhit set
        return None         # all sets were hit

    hitting_sets_list = []
    stack = [[]]
    counter = 0

    while stack:    # DFS
        counter += 1
        path = stack.pop()
        print(counter, "path =", path)

        unhit_set = first_unhit_set(path)
        print(counter, "unhit_set =", unhit_set)

        if unhit_set is None:
            hitting_sets_list.append(path)
            print(counter, "hitting sets list =", hitting_sets_list)
            continue

        for item in unhit_set:
            if item not in path:
                stack.append(path + [item])
                print(counter, "path+item =", stack)

    hitting_sets = set()    # creating an empty set for the hitting sets
    hitting_sets.update(frozenset(sets) for sets in hitting_sets_list)  # converting the lists to sets
    min_hitting_sets = hitting_sets.copy()
    
    for hit_set in hitting_sets:
        for hit_set_compare in hitting_sets:
            if hit_set_compare != hit_set and hit_set.issuperset(hit_set_compare):  # checking if the hitting set is a superset and ensuring it is not compared to itself
                min_hitting_sets.remove(hit_set)    # filtering out the supersets

    min_hitting_sets_list = [list(sets) for sets in min_hitting_sets]   # converting the sets back to lists

    return hitting_sets_list, min_hitting_sets_list
